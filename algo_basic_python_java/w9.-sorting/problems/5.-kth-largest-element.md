# 5. Kth Largest Element \(M\)

## Problem

[https://www.lintcode.com/problem/kth-largest-element/](https://www.lintcode.com/problem/kth-largest-element/)

### Description 

Find K-th largest element in an array.

### Example

**Example 1:**

```text
Input:
n = 1, nums = [1,3,4,2]
Output:
4
```

**Example 2:**

```text
Input:
n = 3, nums = [9,3,2,4,8]
Output:
4
```

## Approach: Quick Select

### Intuition:

Use pivot to divide array into three parts, then locate the **kth** element in them than keep dividing that part based on pivot

{% hint style="warning" %}
In quick sort pivot actually divide array into three parts 

* Those smaller than pivot
* Those larger than pivot
* The value equals to pivot 
  * Since after left++/right--, the worst case is there might be one value exist between left/right
{% endhint %}

### Algorithm: 

Pick an element in the middle of array, called pivot, then divide array into three parts. Note that here the array we divided into would be descending order \(start as biggest one\). Later identify the location of that kth element, then deploy the partition in that specific array. 

#### Step by step: 

* Choose middle as pivot and divide array into three parts
* Identify the kth element location in these three parts, and so the same partition algorithm in that part
* Recursively would find that particular element

### Code

{% tabs %}
{% tab title="Python" %}
```python
class Solution:
    """
    @param n: An integer
    @param nums: An array
    @return: the Kth largest element
    """
    def kthLargestElement(self, n, nums):
        # write your code here
        if not nums:
            return -1
        return self.quick_select(nums, 0, len(nums) - 1, n)
    
    def quick_select(self, nums, start, end, n):
        if start == end:
            return nums[start]
        
        left = start
        right = end
        pivot = nums[start + (end - start)//2]

        while left <= right:
            while left <= right and nums[left] > pivot:
                left+=1
            while left <= right and nums[right] < pivot:
                right-=1
            if left <= right:
                nums[left], nums[right] = nums[right], nums[left]
                left+=1
                right-=1
        
        #WARNING!
        # if k = 1th, then start == j, also k start from 1
        if start + n - 1 <= right:
            return self.quick_select(nums, start, right, n)
        if start + n - 1 >= left:
            #WARNING!
            # since left part don't care, k should reduct them
            return self.quick_select(nums, left, end, n - (left - start ))
        return nums[right + 1]
```
{% endtab %}

{% tab title="Java" %}
```java
public class Solution {
    /**
     * @param A: sorted integer array A
     * @param B: sorted integer array B
     * @return: A new sorted integer array
     */
    public int[] mergeSortedArray(int[] A, int[] B) {
        // write your code here
        int a = 0, b = 0;
        // pointers to A, B respeactively
        int la = A.length, lb = B.length;
        int[] res = new int[la + lb];

        for (int k = 0; k < la + lb; k++) {
            // WARNING!
            // b should >= lb, since when equals the index is already out of range
            if (a < la && (b >=lb || A[a] < B[b])) {
                res[k] = A[a];
                a++;
            } else {
                res[k] = B[b];
                b++;
            }
        }
        return res;
    }
}
```
{% endtab %}
{% endtabs %}

### Complexity Analysis

* **Time Complexity:** **O\(n\)**
  * It's like the half version of quick sort, and the total operation times can be calculated based on:
    * n + n/2 + n/4 + ....= n\(1 + 1/2 + 1/4 + ...\) = 2n, therefore O\(n\)
* **Space Complexity: O\(logn\)**
  * Heap: O\(1\)
  * Stack: O\(logn\)

