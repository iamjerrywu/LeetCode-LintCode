# 6. Merge Two Sorted Arrays \(E\)

## Problem



### Description 

Given an integer array, sort it in ascending order in place. Use quick sort, merge sort, heap sort or any O\(nlogn\) algorithm.

### Example

**Example1:**

```text
Input: [3, 2, 1, 4, 5], 
Output: [1, 2, 3, 4, 5].
```

**Example2:**

```text
Input: [2, 3, 1], 
Output: [1, 2, 3].
```

## Approach: Quick Sort

### Intuition:

Use pivot to divide array of number into two group, and so on and so forth to keep them in order

### Algorithm: 

Pick an element in the middle of array, called pivot. Then reorder the array making values less than pivot come before pivot, while those greater than it comes after. Doing this partition recursively, would reduce problem size \(divide and conquer\)

#### Step by step: 

* Pick middle of the input array value as pivot
* Partition: 
  * Two pointers on each end of the array, and swap their value if they are not in the rightful position
    * left values &lt; pivot, right values &gt; pivot
  * After swap, pointer should move on one more step
* Recursively doing partition until two pointers meet together

## Code

{% tabs %}
{% tab title="Python" %}
```python
class Solution:
    """
    @param A: sorted integer array A
    @param B: sorted integer array B
    @return: A new sorted integer array
    """
    def mergeSortedArray(self, A, B):
        # write your code here
        la, lb = len(A), len(B)
        # pointers to A, B respeactively
        a, b = 0, 0
        res = [0] * (la + lb)
        
        for k in range(la + lb):
            # WARNING!
            # b should >= lb, since when equals the index is already out of range
            if a < la and (b >= lb or A[a] < B[b]):
                res[k] = A[a]
                a+=1
            else:
                res[k] = B[b]
                b+=1
        return res
```
{% endtab %}

{% tab title="Java" %}
```java
public class Solution {
    /**
     * @param A: an integer array
     * @return: nothing
     */
    public void sortIntegers2(int[] A) {
        // write your code here
        if (A == null || A.length == 0) {
            return;
        }
        // start quick sort 
        quickSort(A, 0, A.length - 1);
    }

    private void quickSort(int[] A, int start, int end) {
        if (start >= end) {
            return;
        }
     
        int left = start, right = end;

        // 1. select pivot, between A[start], A[end], get value not index 
        int pivot = A[start + (end - start)/2];

        // 2. left <= right not left < right
        while (left <= right) {
            // traverse left and right for values that need to be swap
            while(left <= right && A[left] < pivot) {
                left++;
            }
            while(left <= right && A[right] > pivot) {
                right--;
            }
            // swap value 
            if (left <= right) {
                int tmp = A[left];
                A[left] = A[right];
                A[right] = tmp;
                left++;
                right--;
            }
        }
        // keep sorting the rmained left/right parts
        quickSort(A, start, right);
        quickSort(A, left, end);
    }
}
```
{% endtab %}
{% endtabs %}

## Complexity Analysis

* **Time Complexity:** **O\(n\)**
  * The pivot we choose impact the time complexity
    * Worst: **O\(n^2\)**
      * If pivot = index0, since every partition level: n, n-1, n-2...1
    * Best: **O\(nlog\(n\)\)**
      * If pivot = middle index
* **Space Complexity: O\(1\)**
  * Since during partition no extra space needed \(**O\(1\)**\)
  * Only need to analyze call stack frame:
    * Worst: **O\(n\)**
      * If pivot = index0, require n -1 times stack calling
    * Best: **O\(logn\)**
      * If pivot = middle index

