# 464. Sort Integers II \(E\)

## Problem

[https://www.lintcode.com/problem/464/](https://www.lintcode.com/problem/merge-two-sorted-arrays)

### Description 

Merge two given sorted ascending integer array _A_ and _B_ into a new sorted integer array.

### Example

**Example 1:**

```text
Input:  A=[1], B=[1]
Output: [1,1]	
Explanation:  return array merged.
```

**Example 2:**

```text
Input:  A=[1,2,3,4], B=[2,4,5,6]
Output: [1,2,2,3,4,4,5,6]	
Explanation: return array merged.
```

## Approach: Quick Sort

### Intuition:

Two pointers on A/B array, and compares their values with each other 

### Algorithm: 

Two pointers traverse A/B array, and pick the minimum one into result. The result array length equals to length of A plus length of B. 

#### Step by step: 

* Two pointers on start of A/B array
* Traverse in total length of A/B: 
  * If pointer in valid range then compare values and put the smaller one into result
  * pointer ++ after each round

## Code

{% tabs %}
{% tab title="Python" %}
```python
class Solution:
    """
    @param A: sorted integer array A
    @param B: sorted integer array B
    @return: A new sorted integer array
    """
    def mergeSortedArray(self, A, B):
        # write your code here
        la, lb = len(A), len(B)
        # pointers to A, B respeactively
        a, b = 0, 0
        res = [0] * (la + lb)
        
        for k in range(la + lb):
            # WARNING!
            # b should >= lb, since when equals the index is already out of range
            if a < la and (b >= lb or A[a] < B[b]):
                res[k] = A[a]
                a+=1
            else:
                res[k] = B[b]
                b+=1
        return res
```
{% endtab %}

{% tab title="Java" %}
```java
public class Solution {
    /**
     * @param A: an integer array
     * @return: nothing
     */
    public void sortIntegers2(int[] A) {
        // write your code here
        if (A == null || A.length == 0) {
            return;
        }
        // start quick sort 
        quickSort(A, 0, A.length - 1);
    }

    private void quickSort(int[] A, int start, int end) {
        if (start >= end) {
            return;
        }
     
        int left = start, right = end;

        // 1. select pivot, between A[start], A[end], get value not index 
        int pivot = A[start + (end - start)/2];

        // 2. left <= right not left < right
        while (left <= right) {
            // traverse left and right for values that need to be swap
            while(left <= right && A[left] < pivot) {
                left++;
            }
            while(left <= right && A[right] > pivot) {
                right--;
            }
            // swap value 
            if (left <= right) {
                int tmp = A[left];
                A[left] = A[right];
                A[right] = tmp;
                left++;
                right--;
            }
        }
        // keep sorting the rmained left/right parts
        quickSort(A, start, right);
        quickSort(A, left, end);
    }
}
```
{% endtab %}
{% endtabs %}

## Complexity Analysis

* **Time Complexity:** **O\(n\)**
  * The pivot we choose impact the time complexity
    * Worst: **O\(n^2\)**
      * If pivot = index0, since every partition level: n, n-1, n-2...1
    * Best: **O\(nlog\(n\)\)**
      * If pivot = middle index
* **Space Complexity: O\(1\)**
  * Since during partition no extra space needed \(**O\(1\)**\)
  * Only need to analyze call stack frame:
    * Worst: **O\(n\)**
      * If pivot = index0, require n -1 times stack calling
    * Best: **O\(logn\)**
      * If pivot = middle index



