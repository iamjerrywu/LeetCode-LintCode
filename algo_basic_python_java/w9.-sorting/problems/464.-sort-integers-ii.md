# 464. Sort Integers II \(E\)

## Problem

[https://www.lintcode.com/problem/464/](https://www.lintcode.com/problem/merge-two-sorted-arrays)

### Description 

Given an integer array, sort it in ascending order in place. Use quick sort, merge sort, heap sort or any O\(nlogn\) algorithm.

### Example

**Example1:**

```text
Input: [3, 2, 1, 4, 5], 
Output: [1, 2, 3, 4, 5].
```

**Example2:**

```text
Input: [2, 3, 1], 
Output: [1, 2, 3].
```

## Approach: Quick Sort

### Intuition:

Use pivot to divide array of number into two group, and so on and so forth to keep them in order

### Algorithm: 

Pick an element in the middle of array, called pivot. Then reorder the array making values less than pivot come before pivot, while those greater than it comes after. Doing this partition recursively, would reduce problem size \(divide and conquer\)

#### Step by step: 

* Pick middle of the input array value as pivot
* Partition: 
  * Two pointers on each end of the array, and swap their value if they are not in the rightful position
    * left values &lt; pivot, right values &gt; pivot
  * After swap, pointer should move on one more step
* Recursively doing partition until two pointers meet together

## Code

{% tabs %}
{% tab title="Python" %}
```python
class Solution:
    """
    @param A: an integer array
    @return: nothing
    """
    def sortIntegers2(self, A):
        # write your code here
        if not A: 
            return 
        self.quick_sort_helper(A, 0, len(A) - 1)
    def quick_sort_helper(self, A, start, end):
        if start >= end:
            return 
        
        left, right = start, end
        # select pivot 
        pivot = A[start + (end - start)//2]
        
        # WARNING!
        # should be left <= right, not 
        # since right/left should not on same index
        # if <, then partition will contain repeated number in two parts
        while left <= right:
            # WARNING!
            # shuold be A[left]/A[right] < pivot
            # since if <= pivot, when processing an array with same value
            # would end up one parts contains all value but the other empty
            while left <= right and A[left] < pivot:
                left+=1
            
            # shift right if value > pivot
            while right >= left and A[right] > pivot:
                right-=1
            
            # exchange value
            if left <= right:
                A[left], A[right] = A[right], A[left]
                left+=1
                right-=1
        
        # keep doing partition        
        self.quick_sort_helper(A, start, right)
        self.quick_sort_helper(A, left, end)
```
{% endtab %}

{% tab title="Java" %}
```java
public class Solution {
    /**
     * @param A: an integer array
     * @return: nothing
     */
    public void sortIntegers2(int[] A) {
        // write your code here
        if (A == null || A.length == 0) {
            return;
        }
        // start quick sort 
        quickSort(A, 0, A.length - 1);
    }

    private void quickSort(int[] A, int start, int end) {
        if (start >= end) {
            return;
        }
     
        int left = start, right = end;

        // 1. select pivot, between A[start], A[end], get value not index 
        int pivot = A[start + (end - start)/2];

        // 2. left <= right not left < right
        while (left <= right) {
            // traverse left and right for values that need to be swap
            while(left <= right && A[left] < pivot) {
                left++;
            }
            while(left <= right && A[right] > pivot) {
                right--;
            }
            // swap value 
            if (left <= right) {
                int tmp = A[left];
                A[left] = A[right];
                A[right] = tmp;
                left++;
                right--;
            }
        }
        // keep sorting the rmained left/right parts
        quickSort(A, start, right);
        quickSort(A, left, end);
    }
}
```
{% endtab %}
{% endtabs %}

## Complexity Analysis

* **Time Complexity:** **O\(n\)**
  * The pivot we choose impact the time complexity
    * Worst: **O\(n^2\)**
      * If pivot = index0, since every partition level: n, n-1, n-2...1
    * Best: **O\(nlog\(n\)\)**
      * If pivot = middle index
* **Space Complexity: O\(1\)**
  * Since during partition no extra space needed \(**O\(1\)**\)
  * Only need to analyze call stack frame:
    * Worst: **O\(n\)**
      * If pivot = index0, require n -1 times stack calling
    * Best: **O\(logn\)**
      * If pivot = middle index



