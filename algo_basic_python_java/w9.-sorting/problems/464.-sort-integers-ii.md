# 464. Sort Integers II \(E\)

## Problem

[https://www.lintcode.com/problem/464/](https://www.lintcode.com/problem/merge-two-sorted-arrays)

### Description 

Merge two given sorted ascending integer array _A_ and _B_ into a new sorted integer array.

### Example

**Example 1:**

```text
Input:  A=[1], B=[1]
Output: [1,1]	
Explanation:  return array merged.
```

**Example 2:**

```text
Input:  A=[1,2,3,4], B=[2,4,5,6]
Output: [1,2,2,3,4,4,5,6]	
Explanation: return array merged.
```

## Approach: Quick Sort

### Intuition:

Two pointers on A/B array, and compares their values with each other 

### Algorithm: 

Two pointers traverse A/B array, and pick the minimum one into result. The result array length equals to length of A plus length of B. 

#### Step by step: 

* Two pointers on start of A/B array
* Traverse in total length of A/B: 
  * If pointer in valid range then compare values and put the smaller one into result
  * pointer ++ after each round

### Code

{% tabs %}
{% tab title="Python" %}
```python
class Solution:
    """
    @param A: sorted integer array A
    @param B: sorted integer array B
    @return: A new sorted integer array
    """
    def mergeSortedArray(self, A, B):
        # write your code here
        la, lb = len(A), len(B)
        # pointers to A, B respeactively
        a, b = 0, 0
        res = [0] * (la + lb)
        
        for k in range(la + lb):
            # WARNING!
            # b should >= lb, since when equals the index is already out of range
            if a < la and (b >= lb or A[a] < B[b]):
                res[k] = A[a]
                a+=1
            else:
                res[k] = B[b]
                b+=1
        return res
```
{% endtab %}

{% tab title="Java" %}
```java
public class Solution {
    /**
     * @param A: sorted integer array A
     * @param B: sorted integer array B
     * @return: A new sorted integer array
     */
    public int[] mergeSortedArray(int[] A, int[] B) {
        // write your code here
        
        // pointers to A, B respeactively
        int a = 0, b = 0;
        int la = A.length, lb = B.length;
        int[] res = new int[la + lb];

        for (int k = 0; k < la + lb; k++) {
            // WARNING!
            // b should >= lb, since when equals the index is already out of range
            if (a < la && (b >=lb || A[a] < B[b])) {
                res[k] = A[a];
                a++;
            } else {
                res[k] = B[b];
                b++;
            }
        }
        return res;
    }
}
```
{% endtab %}
{% endtabs %}

### Complexity Analysis

* **Time Complexity:** **O\(n^2\)/O\(nlog\(n\)\)**
  * The pivot we choose impact the time complexity
    * Worst: **O\(n^2\)**
      * If pivot = index0, since every partition level: n, n-1, n-2...1
    * Best: **O\(nlog\(n\)\)**
      * If pivot = middle index
* **Space Complexity: O\(n\)/O\(logn\)**
  * Since during partition no extra space needed \(**O\(1\)**\)
  * Only need to analyze call stack frame:
    * Worst: **O\(n\)**
      * If pivot = index0, require n -1 times stack calling
    * Best: **O\(logn\)**
      * If pivot = middle index



