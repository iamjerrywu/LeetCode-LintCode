# 457. Classical Binary Search

## Problem

[https://www.lintcode.com/problem/457/](https://www.lintcode.com/problem/457/)

#### Description

Find any position of a target number in a **sorted** array. Return `-1` if target does not exist.

### Example

**Example 1:**

```text
Input: nums = [1,2,2,4,5,5], target = 2
Output: 1 or 2
```

**Example 2:**

```text
Input: nums = [1,2,2,4,5,5], target = 6
Output: -1
```

## Approach: Recursion

### Intuition:

Recursively splitting the sorted array into two halves, then identify the target located part and keep splitting that part

### Algorithm: 

When ever

#### Step by step: 

* For n&lt;=2, answer = n - 1
* Rest of res = sum of i-1th number and i-2th number

### Code

{% tabs %}
{% tab title="Python" %}
```python
class Solution:
    """
    @param n: an integer
    @return: an ineger f(n)
    """
    def fibonacci(self, n):
        # write your code here
        if n <= 2:
            return n - 1
        return self.fibonacci(n - 2) + self.fibonacci(n - 1)
```
{% endtab %}
{% endtabs %}

### Complexity Analysis

* **Time Complexity:** **O\(2^n\)**
  * The slowest way because it takes exponential time. The amount of operations needed for each level of recursion, grows exponentially as depth approaches N. 
* **Space Complexity: O\(N\)**
  * We need space proportionate to `N` to account for the max size of the stack, in memory. This stack keeps track of the function calls to `fib(N)`. This has the potential to be bad in cases that there isn't enough physical memory to handle the increasingly growing stack, leading to a `StackOverflowError`

