# 480. Binary Tree Paths \(E\)

## Problem

### Description

Given a binary tree, return all root-to-leaf paths.\]

### Example

**Example 1:**

```text
Input：{1,2,3,#,5}
Output：["1->2->5","1->3"]
Explanation：
   1
 /   \
2     3
 \
  5
```

**Example 2:**

```text
Input：{1,2}
Output：["1->2"]
Explanation：
   1
 /   
2     
```

## Approach - DFS

### Intuition

Pre-order traversal to traverse all the nodes in tree, and store their values in a list

### Algorithm

Traverse depth first and store them in list \(named `path`\), if reach button node, than store that path inside `result`

#### Step by step 

* Init `path` \(list\), `result`\(list\), if root not null than put root inside path
* DFS
  * If node == null, return 
  * if node don't have left child and right child
    * Store `path` into `result`
  * If have left child or right child, keep DFS

### Code

{% tabs %}
{% tab title="python" %}
```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
class Solution:
    """
    @param root: the root of the binary tree
    @return: all root-to-leaf paths
    """
    def binaryTreePaths(self, root):
        # write your code here
        # result
        res = []
        if not root:
            res
        # put root node inside path
        path = [root]
        self.find_path(root, path, res)
        return paths
    def find_path(self, node, path, res):
        if not node:
            return
        if not node.left and not node.right:
            paths.append('->'.join([str(n.val) for n in path]))
            return paths
        
        path.append(node.left)
        self.find_path(node.left, path, paths)
        path.pop()

        path.append(node.right)
        self.find_path(node.right, path, paths)
        path.pop()
```
{% endtab %}

{% tab title="java" %}
```java

```
{% endtab %}
{% endtabs %}

