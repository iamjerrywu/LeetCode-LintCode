# 69. Binary Tree Level Order Traversal

## Problem

### Description

Given a binary tree, return the level order traversal of its nodes' values. \(ie, from left to right, level by level\).

### Example

**Example 1:**

```text
Input：{1,2,3}
Output：[[1],[2,3]]
Explanation：
  1
 / \
2   3
it will be serialized {1,2,3}
level order traversal
```

**Example 2:**

```text
Input：{1,#,2,3}
Output：[[1],[2],[3]]
Explanation：
1
 \
  2
 /
3
it will be serialized {1,#,2,3}
level order traversal
```

## Approach - Queue

### Intuition

Put every level's nodes into queue, and traverse that level's node and put their values into result list

### Algorithm

Use queue to store \(put from right\) nodes, and traverse \(pop from left\) their values and put into result list

#### Step by Step

* Init queue and put root in as 1st element 
* If queue not empty
  * Traverse every level of queue and obtains their values 

### Code

{% tabs %}
{% tab title="Python" %}
```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

class Solution:
    """
    @param root: A Tree
    @return: Level order a list of lists of integer
    """
    def levelOrder(self, root):
        # write your code here
        if not root:
            return []
        
        # step 1: put the first level into queue
        queue = collections.deque([root])
        res = []
        # step2: while queue not empty
        while queue:
            # step3: put every level (queue) value into result
            res.append([node.val for node in queue])
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return res
                

```
{% endtab %}

{% tab title="Java" %}
```java

```
{% endtab %}
{% endtabs %}

### Complexity Analysis

