# 130. Heapify

## Problem

[https://www.lintcode.com/problem/130/](https://www.lintcode.com/problem/130/)

### Description 

Given an integer array, heapify it into a min-heap array.

For a heap array A, A\[0\] is the root of heap, and for each A\[i\], A\[i  _2 + 1\] is the left child of A\[i\] and A\[i_  2 + 2\] is the right child of A\[i\].

{% hint style="info" %}
#### Clarification

_**What is heap?**_ _**What is heapify?**_ _**What if there is a lot of solutions?**_

* Heap is a data structure, which usually have three methods: push, pop and top. where "push" add a new element the heap, "pop" delete the minimum/maximum element in the heap, "top" return the minimum/maximum element.
* Convert an unordered integer array into a heap array. If it is min-heap, for each element A\[i\], we will get A\[i \* 2 + 1\] &gt;= A\[i\] and A\[i \* 2 + 2\] &gt;= A\[i\].
* Return any of them.
{% endhint %}

### Example

_**Example 1**_

```text
Input : [3,2,1,4,5]
Output : [1,2,3,4,5]
Explanation : return any one of the legitimate heap arrays
```

{% hint style="danger" %}
#### Challenge

O\(n\) time complexity
{% endhint %}

## Approach - Shift Down

### Intuition 

Traverse the hashtable list, get each node then put them in the double-sized result

### Algorithm

Traverse the hahstable list, get each node \(if null by-pass\) and put them in the double-sized result, their locations would be values%double\_size

#### Step by step

* Init result as list which double the size of original hash list
  * Init each value with null
* Traverse original hash list and get node
  * If not node, calculate the location that meant to be put in result
    * Here location = val%size, note that in Java/C++, negative values should plus size after MOD
      * If result\[location\] already occupied, keeping search along the linked list tailing that location
      * If not occupied, assign new node in that location
* Return result

### Code

{% tabs %}
{% tab title="python" %}
```python

```
{% endtab %}

{% tab title="java" %}
```java

```
{% endtab %}
{% endtabs %}

### Complexity Analysis

* **Time Complexity: O\(n\)**
  * Traverse all node in hashtable 
* **Space Complexity: O\(n\)**
  * Heap for result

