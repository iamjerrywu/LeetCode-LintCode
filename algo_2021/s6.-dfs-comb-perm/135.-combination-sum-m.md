# 135. Combination Sum \(M\)

## Problem

[https://www.lintcode.com/problem/combination-sum](https://www.lintcode.com/problem/combination-sum)

### Description

Given a set of candidtate numbers `candidates` and a target number `target`. Find all unique combinations in `candidates` where the numbers sums to `target`.

The **same** repeated number may be chosen from `candidates` unlimited number of times.

### Example

**Example 1:**

```text
Input: candidates = [2, 3, 6, 7], target = 7
Output: [[7], [2, 2, 3]]
```

**Example 2:**

```text
Input: candidates = [1], target = 3
Output: [[1, 1, 1]]
```

## Approach - Iteration

The approach is really similar to "17. Subset" - approach Iteration

### Intuition

Starting from every index, iteratively find the every permutations \(use set to record those have already visited\), and also take care the repeated character in array that try not to traverse it

### Algorithm 

First eliminate repeated elements in candidates array than sorted, then Iteratively traverse the `candidates`array, and started from index 0, then find every combination that **start with that** index \(need to check the target values whether reach goal or not\)

#### Step by step

* `Set` the candidates then sort it 
* Init array `res` \(2D\), `combination`\(1D\)
* Start from index 0, and recursively traverse from index + 1 to find all the combination that starts from index 0
  * When the target reach:
    * &lt; 0, means too much, break the iteration
    * == 0, means reach goal, can add comination to result
  * Need to pop out the top element in stack in order to trace back
  * i.e: \[1,2,3\] -&gt; \[1,3\], need to first pop out 3 then pop out 2, then add 3

### Code

{% tabs %}
{% tab title="python" %}
```python
class Solution:
    """
    @param str: A string
    @return: all permutations
    """
    def stringPermutation2(self, str):
        # write your code here
        res = []
        if str is None:
            return res     
        str = sorted(str)
        self.dfs(0, str, set(), [], res)
        return res
        
    def dfs(self, index, str, visited, permutation, res):
        if len(visited) == len(str):
            # output as string 
            res.append(''.join(permutation))
            return
        for i in range(len(str)):
            if i in visited:
                continue
            # eliminate the repeated values 
            if i > 0 and str[i] == str[i - 1] and i - 1 not in visited:
                continue
            visited.add(i)
            permutation.append(str[i])
            self.dfs(i, str, visited, permutation, res)
            permutation.pop()
            visited.remove(i)

```
{% endtab %}

{% tab title="java" %}
```java
public class Solution {
    /**
     * @param str: A string
     * @return: all permutations
     */
    public List<String> stringPermutation2(String str) {
        // write your code here
        List<String> res = new ArrayList<>();
        
        if (str == null) {
            return res;
        }
        char[] s = str.toCharArray();
        // sort array 
        Arrays.sort(s);
        dfs(0, s, new boolean[str.length()], "", res);
        return res;
    }

    private void dfs(int index, 
                     char[] s, 
                     boolean[] visited, 
                     String permutation,
                     List<String> res) {
        if (permutation.length() == s.length) {    
            res.add(permutation);
            return;
        }
        for (int i = 0; i < s.length; i++) {
            if (visited[i] == true) {
                continue;
            }
            if (i > 0 && s[i] == s[i - 1] && visited[i - 1] == false) {
                continue;
            }            
            visited[i] = true;
            // WARNING!
            // Here since at the same level we don't want to keep to s[i] in String
            // Pass it to call stack frame instead of adding in the same loop level
            dfs(i, s, visited, permutation + s[i], res);
            visited[i] = false;
        }
    }
}
```
{% endtab %}
{% endtabs %}

### Complexity Analysis

* **Time Complexity: O\(n\*n!\)**
  * Sorted: O\(nlogn\)
  * Recursion: O\(n\*n!\)
    * Permutation have n! kinds
    * When deep copy permutation to result, require O\(n\)
* **Space Complexity: O\(n\)**
  * Need to allocate new array `permutation`, and set `visited` 

