# 10. String Permutations II \(M\)

## Problem

[https://www.lintcode.com/problem/15/](https://www.lintcode.com/problem/15/)

### Description

Given a string, find all permutations of it without duplicates.

### Example

**Example 1:**

```text
Input: "abb"
Output:
["abb", "bab", "bba"]
```

**Example 2:**

```text
Input: "aabb"
Output:
["aabb", "abab", "baba", "bbaa", "abba", "baab"]
```

## Approach - Iteration

The approach is really similar to Integer "16.Permutations II" Problem

### Intuition

Starting from every index, iteratively find the every permutations \(use set to record those have already visited\), and also take care the repeated character in array that try not to traverse it

### Algorithm 

Iteratively traverse the array, and started from index 0, then find every permutations that start with that index. When finding one specific permutations, in order to not finding the repeated character in array, use set to record those value that had already visited. Once the set length == nums length, means all values in array had be traversed. Moreover, take care the repeated values that should not be traversed

#### Step by step

* Init array `res` \(2D\), `permutation`\(1D\), `set`
* Sort the array `nums` \(optional\)
* Start from index 0, and recursively traverse from index + 1 to find all the permutation that starts from index 0
  * Check set whether nums\[i\] haven't been visited or not
    * If yes, continue
    * If not, go on 
  * Check nums\[i\] == nums\[i - 1\] and visited\[i - 1\] = false \(means it had already been visited\)
    * If yes, continue
    * It not, add i into set, and add nums\[i\] into permutation
      * Remember to traceback permutation and visited set
  * Recursively do it
  * Once permutation length == nums's length, add permutation to result

### Code

{% tabs %}
{% tab title="python" %}
```python
class Solution:
    """
    @param str: A string
    @return: all permutations
    """
    def stringPermutation2(self, str):
        # write your code here
        res = []
        if str is None:
            return res     
        str = sorted(str)
        self.dfs(0, str, set(), [], res)
        return res
        
    def dfs(self, index, str, visited, permutation, res):
        if len(visited) == len(str):
            # output as string 
            res.append(''.join(permutation))
            return
        for i in range(len(str)):
            if i in visited:
                continue
            # eliminate the repeated values 
            if i > 0 and str[i] == str[i - 1] and i - 1 not in visited:
                continue
            visited.add(i)
            permutation.append(str[i])
            self.dfs(i, str, visited, permutation, res)
            permutation.pop()
            visited.remove(i)

```
{% endtab %}

{% tab title="java" %}
```java
public class Solution {
    /**
     * @param str: A string
     * @return: all permutations
     */
    public List<String> stringPermutation2(String str) {
        // write your code here
        List<String> res = new ArrayList<>();
        
        if (str == null) {
            return res;
        }
        char[] s = str.toCharArray();
        // sort array 
        Arrays.sort(s);
        dfs(0, s, new boolean[str.length()], "", res);
        return res;
    }

    private void dfs(int index, 
                     char[] s, 
                     boolean[] visited, 
                     String permutation,
                     List<String> res) {
        if (permutation.length() == s.length) {    
            res.add(permutation);
            return;
        }
        for (int i = 0; i < s.length; i++) {
            if (visited[i] == true) {
                continue;
            }
            if (i > 0 && s[i] == s[i - 1] && visited[i - 1] == false) {
                continue;
            }            
            visited[i] = true;
            // WARNING!
            // Here since at the same level we don't want to keep to s[i] in String
            // Pass it to call stack frame instead of adding in the same loop level
            dfs(i, s, visited, permutation + s[i], res);
            visited[i] = false;
        }
    }
}
```
{% endtab %}
{% endtabs %}

### Complexity Analysis

* **Time Complexity: O\(n\*n!\)**
  * Sorted: O\(nlogn\)
  * Recursion: O\(n\*n!\)
    * Permutation have n! kinds
    * When deep copy permutation to result, require O\(n\)
* **Space Complexity: O\(n\)**
  * Need to allocate new array `permutation`, and set `visited` 

